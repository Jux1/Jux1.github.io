<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/01/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>测试blog</title>
    <url>/2022/01/31/%E6%B5%8B%E8%AF%95blog/</url>
    <content><![CDATA[<h2 id="text"><a href="#text" class="headerlink" title="text"></a>text</h2><p>测试成功</p>
<h2 id="图片测试"><a href="#图片测试" class="headerlink" title="图片测试"></a>图片测试</h2><p><img src="/2022/01/31/%E6%B5%8B%E8%AF%95blog/v2-b5bac0731e9e7c3f1e4d3d21466a0dff_hd.jpg" alt="v2-b5bac0731e9e7c3f1e4d3d21466a0dff_hd"></p>
<p>图片测试成功</p>
<h2 id="代码块样式测试"><a href="#代码块样式测试" class="headerlink" title="代码块样式测试"></a>代码块样式测试</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>text</category>
      </categories>
      <tags>
        <tag>text</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假每日一题 week1</title>
    <url>/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<h2 id="寒假每日一题"><a href="#寒假每日一题" class="headerlink" title="寒假每日一题"></a><a href="https://www.acwing.com/activity/content/88/"><strong>寒假每日一题</strong></a></h2><p>[TOC]</p>
<h2 id="2022-1-14-闪烁-状态压缩-找环"><a href="#2022-1-14-闪烁-状态压缩-找环" class="headerlink" title="2022/1/14 闪烁                                                    状态压缩 找环"></a><a href="https://www.acwing.com/activity/content/problem/content/6513/">2022/1/14 闪烁</a>                                                    状态压缩 找环</h2><p>一共有16个灯泡               2^16=65536 个状态<br>如果暴力法：时间复杂度O（NB）  10^16级别，一定会超时，需要考虑优化<br><strong>分析</strong>：从某个状态开始，每变一步会到下一个状态，会变10^15次，<strong>但是我们一共只有2^16次 必然会出现循环</strong><br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220114110521401.png" alt="image-20220114110521401" style="zoom: 80%;"><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220114112624276.png" alt="image-20220114112624276" style="zoom:80%;"><br>需要注意的是：(状态压缩那里)<br>两个十进制数相或 在c++中会先转换成2进制数再进行或操作<br>如：2|6 = 10|110=110 结果还是6         本题中：<code>state |= x &lt;&lt; i;         res |= (x ^ y) &lt;&lt; i; x异或上y</code><br> 求n的第k位数字：<code>n &gt;&gt; k &amp; 1</code>                            <code>int x = state &gt;&gt; i &amp; 1</code><br><strong>本题主要是位运算操作不熟，导致了花的时间较多</strong></p>
<p>注意第一位跟前一位做 <strong>异或(^)</strong> 运算时的操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL m;     </span><br><span class="line"><span class="keyword">int</span> p[N]; <span class="comment">//表示每个状态是第几步走到的（很容易算出圆的长度）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;	<span class="comment">//res表示下一个状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )	</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = (i - <span class="number">1</span> + n) % n; <span class="comment">//j表示前一位 注意这里的小技巧</span></span><br><span class="line">        <span class="keyword">int</span> x = state &gt;&gt; i &amp; <span class="number">1</span>, y = state &gt;&gt; j &amp; <span class="number">1</span>;</span><br><span class="line">        res |= (x ^ y) &lt;&lt; i;		<span class="comment">//x异或上y</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        cout &lt;&lt; (state &gt;&gt; i &amp; <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )<span class="comment">//枚举每一位</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        state |= x &lt;&lt; i;		<span class="comment">//状态压缩 左移一位相当于*2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span> p); <span class="comment">//初始化p表示没有被搜到过</span></span><br><span class="line">    p[state] = <span class="number">0</span>;			 <span class="comment">//初始状态 第0步被搜到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; i ++ )  <span class="comment">//枚举步数</span></span><br><span class="line">    &#123;</span><br><span class="line">        state = <span class="built_in">update</span>(state);	<span class="comment">//每次先更新 写update函数</span></span><br><span class="line">        <span class="keyword">if</span> (i == m)				<span class="comment">//表示找到了答案</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">print</span>(state);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[state] == <span class="number">-1</span>) <span class="comment">//如果当前状态没被初始化过</span></span><br><span class="line">            p[state] = i;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//表示发现了环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len = i - p[state]; <span class="comment">//环的长度</span></span><br><span class="line">            <span class="keyword">int</span> r = (m - i) % len;	<span class="comment">//当前需要走的步数</span></span><br><span class="line">            <span class="keyword">while</span> (r -- ) state = <span class="built_in">update</span>(state);</span><br><span class="line">            <span class="built_in">print</span>(state);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220114112727124.png" alt="image-20220114112727124" style="zoom: 80%;"></p>
<h2 id="2022-1-15-金发姑娘和N头牛-差分-离散化"><a href="#2022-1-15-金发姑娘和N头牛-差分-离散化" class="headerlink" title="2022/1/15 金发姑娘和N头牛                              差分 离散化"></a><a href="https://www.acwing.com/activity/content/problem/content/6514/">2022/1/15 金发姑娘和N头牛</a>                              差分 离散化</h2><p><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220115234746921.png" alt="image-20220115234746921"><br>一般好多题都是差分加离散化来做的<br>我们来看差分的操作：要将L到R区间内加上c  <code>b[l]+=c   b[r+1]-=c</code><br>我们可以发现操作数只有3 N，只有6万<br>在整个数轴上点数很多，有10^9 但是会被改变的值最多只有6万个，这就意味着绝大部分数都是0<br>所以我们求前缀和的时候0就可以跳过，只需要用我们出现过的数就可以了，所有出现过的数只有<code>6W</code><br><strong>类似这样，取值区间很大，可实际上用到个数很少的问题 用差分来做</strong><br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220116000320101.png" alt="image-20220116000320101"><br>差分有很多实现的方式，在这一题可以用map来实现<br>因为map下标可以用任意的数值<br>又因为本题中我们要按顺序求前缀和，而map是一颗平衡树支持有序去遍历<br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220116001044063.png" alt="image-20220116001044063"><br>方法一：用map来实现差分–离散化            （代码少但效率低)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2e9</span>;	<span class="comment">//正无穷只要比出现过的下标大就行了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        b[-INF] += x;</span><br><span class="line">        b[l] += y - x;</span><br><span class="line">        b[r + <span class="number">1</span>] += z - y;</span><br><span class="line">        b[INF+<span class="number">1</span>] -= z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>;	<span class="comment">//res表示前缀和的最大值 sum表示前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [k, v]: b)	<span class="comment">//枚举差分数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += v;			<span class="comment">//更新前缀和</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, sum);<span class="comment">//最大值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：手写离散化<br>手写离散化实质上就是把map替换掉，我们需要手动去实现一个映射。<br><strong>先将所有出现过的数存下来，排序，排序后将每个数的数值映射成他的下标</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20010</span>, INF = <span class="number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x, y, z;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; xs; <span class="comment">// 将所有出现过的数存下来</span></span><br><span class="line"><span class="keyword">int</span> l[N], r[N], b[N * <span class="number">2</span>];<span class="comment">//b是差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span>	<span class="comment">//求一下这个数值对应的下标是多少</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = xs.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (xs[mid] &gt;= v) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;x, &amp;y, &amp;z);</span><br><span class="line"></span><br><span class="line">    xs.<span class="built_in">push_back</span>(-INF), xs.<span class="built_in">push_back</span>(INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l[i], &amp;r[i]);</span><br><span class="line">        xs.<span class="built_in">push_back</span>(l[i]);</span><br><span class="line">        xs.<span class="built_in">push_back</span>(r[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(xs.<span class="built_in">begin</span>(), xs.<span class="built_in">end</span>());</span><br><span class="line">    xs.<span class="built_in">erase</span>(<span class="built_in">unique</span>(xs.<span class="built_in">begin</span>(), xs.<span class="built_in">end</span>()), xs.<span class="built_in">end</span>());<span class="comment">//判重</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;	<span class="comment">//求左右端点离散化后的值</span></span><br><span class="line">        <span class="keyword">int</span> L = <span class="built_in">find</span>(l[i]), R = <span class="built_in">find</span>(r[i] + <span class="number">1</span>);</span><br><span class="line">        b[<span class="number">0</span>] += x;</span><br><span class="line">        b[L] += y - x;</span><br><span class="line">        b[R] += z - y;</span><br><span class="line">        b[xs.<span class="built_in">size</span>() - <span class="number">1</span>] -= z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; xs.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        sum += b[i];</span><br><span class="line">        res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样例解析：<br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220116225306513.png" alt="image-20220116225306513" style="zoom: 67%;"></p>
<p><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220116225230012.png" alt="image-20220116225230012"><br>上图表示二分离散化时的操作</p>
<h2 id="2022-1-16奶牛棒球-枚举-双指针-二分"><a href="#2022-1-16奶牛棒球-枚举-双指针-二分" class="headerlink" title="2022/1/16奶牛棒球                                                 枚举    双指针   二分"></a><a href="https://www.acwing.com/activity/content/problem/content/6518/">2022/1/16奶牛棒球    </a>                                             枚举    双指针   二分</h2><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220117133141997.png" alt="image-20220117133141997" style="zoom: 67%;">
首先暴力的话枚举三个点 N^3 超时了
但是可以枚举两个点 1000000 10^6，没有超时
可以先去枚举两个数 只占用了N^2的计算量。
然后再去考虑第三个数，计算量只要控制到`logn`就行了
所以可以用双指针或者二分去做
![image-20220117133937512](%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220117133937512.png)
**能不能二分？**时间复杂度是`n^2 logn` 1000^2 * 10=10^7 能过
**能不能双指针？**
要能用双指针，当且仅当两个指针单调(如果一个指针往后走，另一个指针只能往后或者往前走)，本题能用

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">    <span class="built_in">sort</span>(p, p + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">2</span> &lt; n; i ++ )<span class="comment">//细节:给后两个数留出位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>, l = j + <span class="number">1</span>, r = j + <span class="number">1</span>; j + <span class="number">1</span> &lt; n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; n &amp;&amp; p[l] - p[j] &lt; p[j] - p[i]) l ++ ;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; n &amp;&amp; p[r] - p[j] &lt;= <span class="number">2</span> * (p[j] - p[i])) r ++ ;</span><br><span class="line">            res += r - l;	<span class="comment">//注意这里和二分的差别 这里结束后l是L+1 所以可以直接减</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;p[i];</span><br><span class="line">    <span class="built_in">sort</span>(p,p+n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l=j+<span class="number">1</span>,r=n<span class="number">-1</span>,L,R;</span><br><span class="line">            <span class="keyword">int</span> x=p[i],y=p[j];</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(p[mid]&gt;=<span class="number">2</span>*y-x) r=mid; <span class="comment">//二分这里都是&gt;=或者&lt;=</span></span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            L=l;</span><br><span class="line">            <span class="keyword">if</span>(p[L]-y &lt; y-x) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            l=j+<span class="number">1</span>,r=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;	</span><br><span class="line">                <span class="keyword">if</span>(p[mid]-y&lt;=<span class="number">2</span>*(y-x)) l=mid;	<span class="comment">//左边的情况下要注意mid要加1</span></span><br><span class="line">                <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            R=l;</span><br><span class="line">            <span class="keyword">if</span>(p[R]-y &gt; <span class="number">2</span>*(y-x))<span class="keyword">continue</span>;</span><br><span class="line">            res+=R-L+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2022-1-17贝茜放慢脚步-二路归并"><a href="#2022-1-17贝茜放慢脚步-二路归并" class="headerlink" title="2022/1/17贝茜放慢脚步                                        二路归并"></a><a href="https://www.acwing.com/activity/content/problem/content/6523/">2022/1/17贝茜放慢脚步</a>                                        二路归并</h2><p>将所有减速的点排好序<br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220117220434778.png" alt="image-20220117220434778" style="zoom:67%;"><br>反思：写题的时候先总体后细节<br>关键：让时间和距离合并起来<br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220117220707763.png" alt="image-20220117220707763"><br>假设走到这里时，已经走过的时间是t，已经走过的距离是s,v是当前的速度<br>接下来考虑哪个时间更靠前发生，<br>事件a[i]表示第a[i]秒发生这个事件 同理b走到[i]距离发生另一个事件<br>再过多少秒会发生a[i]这个事件？a=a[i]-t,<br>同理：b=(b[i]-s)/v<br>这里v是 1/2 1/3 1/4 1/5 怎么求呢？<br><strong>小技巧</strong>：在这里我们存v的倒数，v就是1 2 3 4 5… 用到的时候变化一下就行了，更方便<br>另外本题还有一个小技巧，就是当长度不确定的时候将数组定义成vector<br>相关vector的操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line">a.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">i &lt; a.<span class="built_in">size</span>() </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a, b;<span class="comment">//长度不确定 定义一个vector更方便</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, str, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;T&#x27;</span>) a.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">else</span> b.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b.<span class="built_in">push_back</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> t = <span class="number">0</span>, s = <span class="number">0</span>, v = <span class="number">1</span>;  <span class="comment">// v 是速度的倒数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.<span class="built_in">size</span>() || j &lt; b.<span class="built_in">size</span>())</span><br><span class="line">        	<span class="comment">//j走完了		或者	i没有走完		并且i在前面</span></span><br><span class="line">        <span class="keyword">if</span> (j == b.<span class="built_in">size</span>() || i &lt; a.<span class="built_in">size</span>() &amp;&amp; a[i] - t &lt; (b[j] - s) * v)</span><br><span class="line">        &#123;</span><br><span class="line">            s += (a[i] - t) / v;</span><br><span class="line">            t = a[i];</span><br><span class="line">            v ++ ;</span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            t += (b[j] - s) * v;</span><br><span class="line">            s = b[j];</span><br><span class="line">            v ++ ;</span><br><span class="line">            j ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.0lf\n&quot;</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2022-1-18-镜子田地-环图-最长路-图的遍历"><a href="#2022-1-18-镜子田地-环图-最长路-图的遍历" class="headerlink" title="2022/1/18 镜子田地                                            环图 最长路 图的遍历"></a><a href="https://www.acwing.com/activity/content/problem/content/6538/">2022/1/18 镜子田地</a>                                            环图 最长路 图的遍历</h2><p>分析之前养成好习惯，先分析数据范围：<br>1&lt;=NM&lt;=1000   数据范围非常大，N和M都非常大<br>所以矩阵最多是有10^6个字符，像这样我们时间复杂度应该控制在O(NM)<br>控制到线性，和方格数量成正比才可以</p>
<p>本题直接看比较难想，可以先转化成一个图论模型：<br>转化成图的话要看<strong>点和边</strong>是什么<br>点：根据镜子(对角线)将一个格子划分成两个点<br>边：一个点如果可以走到另一个点的话就连一个有向边(本题光路可逆，所以是无向边)<br>我们可以发现，只要不是边界的点，都可以连两条边<br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220118231332670.png" alt="image-20220118231332670" style="zoom:80%;"><br>相当是我们要找一条以边界点为起点的路径，使得路径中包含的点数最多<br><strong>就是求最长路</strong> （可以想到<code>spfa</code>）<br>边界的点都只能是简单链，因为点是有限的所以一定会从另一个边界出去<br>内部的点，因为度为2，且点是有限的不能一直延伸，所以最后一定是一个简单环</p>
<p><strong>环图</strong>：对于一个无向图，如果图中所有点的度数都&lt;=2,那么这个图必然是由若干个链和若干个简单环构成.<br>更特殊化的是：如果所有点的度数都是2，那这个图必然是由若干个简单环构成的</p>
<p>分析发现，这个图的结构就是若干个简单链和若干个简单环(这里不明白自己证明)<br>我们要求的是所有链里面最长的一个的长度是多少<br>因为所有的链和环之间都是不相交的 所以可以直接用图的遍历方法<br>还可以发现本题中每个点最多只会遍历两遍(从出/入两个端点射入)<br>所以整个时间复杂度是2倍的点数 即<code>4*N*M</code></p>
<p>代码的话就比较简单：<br><strong>这里重点注意我们偏移量的习惯一般是上右下左0123</strong><br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220118233807113.png" alt="image-20220118233807113" style="zoom: 80%;"><br><code>int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</code></p>
<p><strong>分析每个方向进来后，从哪个方向出去</strong>；<br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220118235059276.png" alt="image-20220118235059276" style="zoom: 80%;"><br>如果是这个方向，末位都是0变1 或者 1变0  这里只需要异或(^)1就ok<br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220118235504087.png" alt="image-20220118235504087" style="zoom: 80%;"><br>这个方向，每一位都变 就可以异或3 即11    （原理同上）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;/&#x27;</span>) d ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> d ^= <span class="number">3</span>;	<span class="comment">//也可以写成d=3-d</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(x + dx[d], y + dy[d], d) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(i, <span class="number">0</span>, <span class="number">1</span>));<span class="comment">//从左往右射 给出方向1</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(i, m - <span class="number">1</span>, <span class="number">3</span>));<span class="comment">//右边的那列边界 方向3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(<span class="number">0</span>, i, <span class="number">2</span>));<span class="comment">//上边界</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(n - <span class="number">1</span>, i, <span class="number">0</span>));<span class="comment">//下边界</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2022-1-19-懒惰的牛-差分-前缀和-双指针"><a href="#2022-1-19-懒惰的牛-差分-前缀和-双指针" class="headerlink" title="2022/1/19 懒惰的牛                                            差分 前缀和 双指针"></a><a href="https://www.acwing.com/activity/content/problem/content/6539/">2022/1/19 懒惰的牛</a>                                            差分 前缀和 双指针</h2><p>首先分析数据范围：<br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220119214818460.png" alt="image-20220119214818460" style="zoom:67%;"><br>草的数量不超过10^5 乘10000 =10^9</p>
<p>可以用前缀和做，因为我们发现可以暴力枚举所有长度为<code>2k</code>的区间，枚举完之后可以求区间里的总和是多少。<br>题目中整个的坐标范围不超过100 w，所以长度为2 k的区间也是不超过100 w个，所以可以枚举每个区间</p>
<img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220119220401545.png" alt="image-20220119220401545" style="zoom:80%;">
用差分做,当牛处于什么位置可以吃到这堆草？
<img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220119220604381.png" alt="image-20220119220604381" style="zoom:50%;">
枚举每堆草，把每堆草对每一只牛的贡献加起来，那么每只牛能吃的就是牛所在那个点的所有贡献
就会变成一个经典的差分问题

<p><strong>双指针</strong><br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220119222156155.png" alt="image-20220119222156155" style="zoom:67%;"><br>区间总和只要算一遍，可以边移动边维护。 移动时加上右边进来的点，减掉左边的点就ok 维护是O(1)的复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span><span class="comment">//双指针法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;<span class="comment">// 这里定义pair是排序两个一起</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">PII q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].y, &amp;q[i].x);</span><br><span class="line">    <span class="built_in">sort</span>(q, q + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        sum += q[i].y;</span><br><span class="line">        <span class="keyword">while</span> (q[i].x - q[j].x &gt; m * <span class="number">2</span>) sum -= q[j ++ ].y;</span><br><span class="line">        res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前缀和写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> s[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123; </span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        s[b + <span class="number">1</span>]= a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">max</span>(<span class="number">1</span>, i - m), r = <span class="built_in">min</span>(i + m, N - <span class="number">1</span>);<span class="comment">//边界情况要考虑</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>差分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, g;</span><br><span class="line">        cin&gt;&gt;g&gt;&gt;x;</span><br><span class="line">        r=<span class="built_in">max</span>(r,x);</span><br><span class="line">        q[<span class="built_in">max</span>(<span class="number">0</span>,x-m)]+=g;</span><br><span class="line">        q[<span class="built_in">min</span>(x+m+<span class="number">1</span>,N<span class="number">-1</span>)]-=g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=q[i];</span><br><span class="line">        res=<span class="built_in">max</span>(res,s);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2022-1-20-公平摄影-前缀和-哈希表"><a href="#2022-1-20-公平摄影-前缀和-哈希表" class="headerlink" title="2022/1/20 公平摄影                                            前缀和 哈希表"></a><a href="https://www.acwing.com/activity/content/problem/content/6540/">2022/1/20 公平摄影                                            前缀和 哈希表</a></h2><p><strong><a href="https://www.acwing.com/solution/content/85577/">题解</a></strong></p>
<p><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220120225424868.png" alt="image-20220120225424868"><br><strong>方法：</strong>全0和全1的情况：就是找连续相邻的一段<br>遍历时每次标记一下遍历的起点和终点<br>每次从前往后遍历的时候判断一下<code>第一个箭头</code>是否和前一个数相同，<br>如果不同：当前这个点就是下一段的起点。<br>如果相同：<code>第二个箭头</code>每次往后延长。</p>
<p>第三种情况：<br>可以枚举这一段的终点，然后枚举这一段的起点。<br><strong>这里涉及到需要快速求区间和</strong> 前缀和<br>对于i来说相当于去找一个最小的j，使得j到i的总和为0<br><strong>这里有个坑</strong>：前缀和是把每个点当成一个单位<br>而本题是把点与点的距离当成一个单位 <strong>所以两个下标就没对映起来</strong><br>需要想一个映射将下标对映起来：<br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220120231341237.png" alt="image-20220120231341237"></p>
<p><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220120231420867.png" alt="image-20220120231420867"></p>
<p>所以相当于在1到i当中找到一个最小的j 使得<code>si-sj.=0</code>即<code>si==sj.</code><br>所以相当于查询最早出现的某个数<br>（查询一个数是否存在，如果存在要他出现最早的位置）<br><strong>查询某个数是否存在用哈希表</strong><br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220120232404264.png" alt="image-20220120232404264"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">PII q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;x, str);</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;G&#x27;</span>) q[i] = &#123;x, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> q[i] = &#123;x, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>, last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hash.<span class="built_in">count</span>(sum)) hash[sum] = q[i].x;</span><br><span class="line">        sum += q[i].y;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">count</span>(sum)) res = <span class="built_in">max</span>(res, q[i].x - hash[sum]);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//全-1或全1</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> || q[i].y != q[i - <span class="number">1</span>].y) last = q[i].x;</span><br><span class="line">        res = <span class="built_in">max</span>(res, q[i].x - last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2022-1-21-奶牛慢跑-栈-思维题"><a href="#2022-1-21-奶牛慢跑-栈-思维题" class="headerlink" title="2022/1/21 奶牛慢跑                                            栈 思维题"></a><a href="https://www.acwing.com/activity/content/problem/content/6541/">2022/1/21 奶牛慢跑                                            栈 思维题</a></h2><p>相当于判断后面一个集合里是否存在vj&lt;vi<br>我们判断一个集合里是否存在一个数小于另外一个数 **等价于** 集合中的最小值是否小于当前数<img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220122233217476.png" alt="image-20220122233217476" style="zoom:80%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, INF = <span class="number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);					<span class="comment">//%*d表示跳过一个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%*d%d&quot;</span>, &amp;v[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, vmin = INF;<span class="comment">//维护最小值所以设为正无穷</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] &lt;= vmin)<span class="comment">//表示牛是队长 不会追尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            res ++ ;</span><br><span class="line">            vmin = v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2022-1-22-COW-记忆化搜索"><a href="#2022-1-22-COW-记忆化搜索" class="headerlink" title="2022/1/22 COW                                                    记忆化搜索"></a><a href="https://www.acwing.com/activity/content/problem/content/6545/">2022/1/22 COW                                                    记忆化搜索</a></h2><p><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220123000045648.png" alt="image-20220123000045648"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> c=<span class="number">0</span>,o=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a:s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">&#x27;C&#x27;</span>)c++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">&#x27;O&#x27;</span>)o+=c;</span><br><span class="line">        <span class="keyword">else</span> w+=o;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;w&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2022-1-24-贝茜的报复-枚举-二进制-DFS"><a href="#2022-1-24-贝茜的报复-枚举-二进制-DFS" class="headerlink" title="2022/1/24 贝茜的报复                                        枚举 二进制    DFS                    "></a><a href="https://www.acwing.com/activity/content/problem/content/6554/">2022/1/24 贝茜的报复                                        枚举 二进制    DFS                    </a></h2><p>做题之前先不考虑优化，先想怎么把题做对。这里就可以先想暴力，暴力一下所有的赋值方案<br>一共有7个变量，每个变量20种情况，总共20^7 大概是10^9级别<br><strong>c++的话一秒钟只能算10^8次</strong>，此题还是会超时。需要做一些优化(从题目本身考虑)<br>本题只是求最终结果的奇偶，不考虑最终结果的值。相当于等式当中模2的余数。<br><strong>取模运算有一些性质</strong>：<br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220125221756537.png" alt="image-20220125221756537" style="zoom:80%;"><br>所以我们发现这题要求最终的余数的话，可以对每一个变量都模2，那么每一项就只有两种情况(原来是20种情况)，现在就变为2^7=128种，我们就可以用枚举去做<br>每一种元素只有两种情况的枚举方案，一般有两种流派：<br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220125222201483.png" alt="image-20220125222201483" style="zoom:80%;"><br>本题采用相对短的二进制写法：<br>我们需要存下每个变量所有的候选值，怎么存呢？<br>本题中我们只关心每个变量取奇数有多少种，取偶数有多少种，<strong>所以我们可以用两个哈希表来存</strong><br><img src="/2022/01/31/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20220125223315621.png" alt="image-20220125223315621" style="zoom:67%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; cnt[<span class="number">2</span>];<span class="comment">//0奇1偶</span></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; x;</span><br><span class="line">      <span class="comment">//这里要注意c++中整数%2是正的 负数是负的 所以取绝对值</span></span><br><span class="line">        cnt[<span class="built_in">abs</span>(x) % <span class="number">2</span>][c] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;BESIGOM&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; v;<span class="comment">//当前方案中每个变量取奇数还是偶数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; <span class="number">7</span>; i ++ )<span class="comment">//遍历所有方案</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j ++ )</span><br><span class="line">            v[str[j]] = i &gt;&gt; j &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((v[<span class="string">&#x27;B&#x27;</span>] + v[<span class="string">&#x27;I&#x27;</span>]) * (v[<span class="string">&#x27;G&#x27;</span>] + v[<span class="string">&#x27;O&#x27;</span>] + v[<span class="string">&#x27;E&#x27;</span>] + v[<span class="string">&#x27;S&#x27;</span>]) * v[<span class="string">&#x27;M&#x27;</span>] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j ++ )</span><br><span class="line">                sum *= cnt[i &gt;&gt; j &amp; <span class="number">1</span>][str[j]];</span><br><span class="line">            res += sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">string s = <span class="string">&quot;BESIGOM&quot;</span>;</span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; even_num, odd_num, a;  <span class="comment">// even_num: 偶数数量， odd_num: 奇数数量 a:表示奇偶</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//  u表示到第几个字母     x表示累计当前符合条件的数量</span></span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">7</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((a[<span class="string">&#x27;B&#x27;</span>] + a[<span class="string">&#x27;I&#x27;</span>]) % <span class="number">2</span> &amp;&amp; (a[<span class="string">&#x27;G&#x27;</span>] + a[<span class="string">&#x27;O&#x27;</span>] + a[<span class="string">&#x27;E&#x27;</span>] + a[<span class="string">&#x27;S&#x27;</span>]) % <span class="number">2</span> &amp;&amp; a[<span class="string">&#x27;M&#x27;</span>] % <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        cnt += x;<span class="comment">//总的要加上当前符合条件的数量</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> c = s[u];</span><br><span class="line">    <span class="keyword">if</span> (even_num[c])&#123;</span><br><span class="line">        a[c] = <span class="number">2</span>;  <span class="comment">// 表示偶数</span></span><br><span class="line">        <span class="built_in">dfs</span>(u + <span class="number">1</span>, x * even_num[c]);  <span class="comment">// 累计当前的符合条件的数量</span></span><br><span class="line">        a[c] = <span class="number">0</span>;  <span class="comment">// 还原</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (odd_num[c]) &#123;</span><br><span class="line">        a[c] = <span class="number">1</span>;  <span class="comment">// 表示奇数</span></span><br><span class="line">        <span class="built_in">dfs</span>(u + <span class="number">1</span>, x * odd_num[c]);  </span><br><span class="line">        a[c] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin  &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="keyword">char</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (!(y % <span class="number">2</span>)) even_num[x] ++;  <span class="comment">// 统计偶数x的数量</span></span><br><span class="line">        <span class="keyword">else</span> odd_num[x] ++;  <span class="comment">// 统计奇数x的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2022/04/22/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>《计算机组成原理》第二章 数据的表示和运算</title>
    <url>/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文主要梳理知识脉络以及对王道课后题的思考，方便后期复习。</p>
<h1 id="2-1数制与编码"><a href="#2-1数制与编码" class="headerlink" title="2.1数制与编码"></a>2.1数制与编码</h1><p>首先是各种进制之间的转换，很简单。这里直接放图：<img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220422220524560.png" alt="image-20220422220524560"></p>
<p>​    <img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220423090306419.png" alt="image-20220423090306419"></p>
<p>D，解析在上图</p>
<h2 id="ASCII码、汉字的表示与编码"><a href="#ASCII码、汉字的表示与编码" class="headerlink" title="ASCII码、汉字的表示与编码"></a>ASCII码、汉字的表示与编码</h2><p>大写字母：65（<strong>010</strong>0 0001）——90（<strong>010</strong>1 1010） 特点:前面固定都是010，后面是1到26的二进制表示。</p>
<p>小写字母：97（<strong>011</strong>0 0001）——122（<strong>011</strong>1 1010）特点：前面固定都是011，后面是1到26的二进制表示。</p>
<p>在ASCII中字母的大小写都是连着的。</p>
<p>区位码：直观，方便人类理解</p>
<p>国标码：区位码+20H，也就是32。</p>
<p>​              防止与ASCII中0~32的“控制通信字符冲突”</p>
<p>汉字内码：国标码+80H，也就是128。</p>
<p>​                  目的：与ASCII兼容。为了和ASCII中的字符区别开，ASCII最高是127。</p>
<p>大端模式：将数据的最高有效字节存放在低地址单元中。</p>
<p>小端模式：将数据的最低有效字节存放在低地址单元中。</p>
<p>地址都是从低到高的，符合我们生活习惯的就是大端模式。例如18、100等。</p>
<h2 id="各种码之间的关系："><a href="#各种码之间的关系：" class="headerlink" title="各种码之间的关系："></a>各种码之间的关系：<img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220422222332521.png" alt="image-20220422222332521" style="zoom:80%;"></h2><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220422222547568.png" alt="image-20220422222547568">



<h3 id="反码"><a href="#反码" class="headerlink" title="反码:"></a>反码:</h3><p>原码转化为补码的一个中间状态，各种特点包括取值范围都和原码一模一样</p>
<h3 id="补码："><a href="#补码：" class="headerlink" title="补码："></a>补码：<img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220422222957126.png" alt="image-20220422222957126"></h3><p>注意：补码的真值0只有一种表示形式。</p>
<p>​           <strong>整数补码中：</strong> （机器字长为7+1位）</p>
<p>​           多出来的一种状态[x]补=1,0000000，<strong>规定为-2^7</strong>，所以补码的整数范围中，负数比正数多出一个最小值。</p>
<p>​           补码的最小值即 符号位为1，其余全为0。这点需要特别注意。题目中经常会对这一点进行考察。</p>
<p>​          <strong>小数补码中：</strong></p>
<p>​           多出来的一种状态[x]补=1,0000000，<strong>规定为-1</strong>，所以补码的小数范围中，负数的最大值就是-1。</p>
<p>​           补码负数的最大值即 符号位为1，其余全为0。也就是-1。</p>
<p><strong>如题1</strong>：</p>
<p><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220422223808983.png" alt="image-20220422223808983"></p>
<p><strong>题解</strong>：“绝对值最大的负数”，也就是负数中最小的那个数。即：符号位为1，其余都为0。也就是-2^(n-1)即-2^63  C</p>
<p><strong>在题目中出现补码，就要特别留意。</strong></p>
<p><strong>如题2：</strong><br><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220422224419628.png" alt="image-20220422224419628" style="zoom:80%;"></p>
<p><strong>解析</strong>：C<br>这类题的通解：</p>
<ol>
<li>补码符号位相同时，数值为越大，他所对应的真值就越大。</li>
<li>-32的原码为 1 100000，要比-32大，绝对值应该更小 数值位&lt;100000。所以原码中x1必须要为0。 </li>
<li>看原码转化为补码的过程中，是否能保证x1取反。将原码转为补码，1,1xxxxx。其中x里面必须要有一个1，才能让x1取反变为1，所以x2~x6中至少要有一个1。(B选项 符号位为1,数值位全为0，原码表示为0，转为补码后表示为-32，-32=-32不满足题目)</li>
</ol>
<p><strong>题3：</strong><br><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220422232957940.png" alt="image-20220422232957940" style="zoom:80%;"></p>
<p><strong>解析：</strong>方法和上题一样，答案为C</p>
<ol>
<li>先写出-16的原码：1,10000 x&lt;-16 ，符号同为负的情况下要让他绝对值最大，即数值位&gt;10000，所以原码中x1必须要为1</li>
<li>转为补码后x1必须为0，数值位&gt;10000中，后面x2<del>x5肯定有一个1，所以x1能够顺利取反变为0，即x2</del>x5可以任取。</li>
</ol>
<p><strong>题4:</strong><br><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220423084112039.png" alt="image-20220423084112039"></p>
<p><strong>解析：</strong>8位寄存器中包含了符号位1位，所以是1+7，写出-66的原码，再转化为补码即可 答案为B</p>
<p><strong>题5：</strong><br><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220423084303724.png" alt="image-20220423084303724"></p>
<p><strong>解析：</strong>寄存器内容为 9BH–&gt;1001 1011 注意第1位为符号位，转为原码后1 110 0101 对应十进制为-101 选C</p>
<p><strong>题6</strong>：<br><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220423084721646.png" alt="image-20220423084721646"></p>
<p><strong>解析：</strong></p>
<p>抓住补码转原码的特点：找到最右边的1,1的右边和原码保持一致，1的左边取反。</p>
<p>不难得出1个1做符号位，表示负数。其他1在最右边时表示补码的值最小</p>
<p>即：1 000 0011这个补码表示的值最小  转为原码：1 111 1101，十进制为-125</p>
<h3 id="移码："><a href="#移码：" class="headerlink" title="移码："></a>移码：</h3><p><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220423085503918.png" alt="image-20220423085503918"></p>
<p>​    <img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220423085711105.png" alt="image-20220423085711105"></p>
<p><strong>本图易得出，当符号位相同时，数值位越大的补码所对应的真值越大</strong></p>
<p><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220423085523331.png" alt="image-20220423085523331"></p>
<p><strong>由上图可知，当题中提到补码表示一个数，一般都要写出数的原码，再转化为补码。</strong></p>
<h2 id="各种码之间的转换方法"><a href="#各种码之间的转换方法" class="headerlink" title="各种码之间的转换方法"></a>各种码之间的转换方法</h2><p><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220423090035870.png" alt="image-20220423090035870"></p>
<h2 id="各类码表示的范围"><a href="#各类码表示的范围" class="headerlink" title="各类码表示的范围"></a>各类码表示的范围</h2><h2 id><a href="#" class="headerlink" title></a><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220423085929870.png" alt="image-20220423085929870"></h2><h3 id="其他值得注意的题"><a href="#其他值得注意的题" class="headerlink" title="其他值得注意的题"></a>其他值得注意的题</h3><p><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220423090202114.png" alt="image-20220423090202114"></p>
<p>主存地址都是正数，不需要符号位，所以选D</p>
<p><img src="/2022/04/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/image-20220423090419444.png" alt="image-20220423090419444"></p>
<p>补码和移码中0都只有一种表示，但是移码是由补码符号位取反得到的，选B</p>
]]></content>
      <categories>
        <category>408考研</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
</search>
